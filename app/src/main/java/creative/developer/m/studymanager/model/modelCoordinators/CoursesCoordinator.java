/*
###############################################################################
Author: Mohammed Alghamdi
Class name : CoursesCoordinator
purpose: This is a model class that coordinates all model classes that are used by courses,
  so that courses view model need to interact only with this class.
Methods:
    getInstance() -> returns the only instance of this class. This class implements Singleton.
    getCoursesStr() -> returns the names of courses
    getCourse() -> get a course name whose name is given.
    getCoursesDay(day) -> returns the courses' objects at a given day sorted by starting time.
    addCourse() -> it adds the the course to the database and the coursesList.
    updateCourse() -> it updates the course on the database and the coursesList.
    removeCourse() -> it remove the course from the database and the coursesList
###############################################################################
 */

package creative.developer.m.studymanager.model.modelCoordinators;

import android.content.Context;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Observable;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import creative.developer.m.studymanager.model.dbFiles.AppDatabase;
import creative.developer.m.studymanager.model.dbFiles.DataRepository;
import creative.developer.m.studymanager.model.dbFiles.EntityFiles.CourseEntity;

public class CoursesCoordinator extends Observable {
    // When adding a row in the database, the row's id is 1 + lastId, so that ids are generated by
    // this class instead of the database. It would behave like AUTO_INCREMENT.
    private int lastId;
    private List<CourseEntity> coursesList;
    private static CoursesCoordinator instance; // this class uses Singleton pattern
    private DataRepository repository;


    /*
     * this constructor builds the only instance.
     * @param context is the context's object of the modelview class.
     */
    public CoursesCoordinator(Context context) {
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> {
            repository = DataRepository.getInstance(AppDatabase.getInstance(context));
            coursesList = repository.getCourses();
            lastId = 0;
            for (CourseEntity course : coursesList) {
                lastId = Math.max(lastId, course.getCourseID());
            }
            CoursesCoordinator.this.setChanged();
            CoursesCoordinator.this.notifyObservers();
        });
    }

    /*
     * This method creates and return THE object/instance of this class.
     * @param context is the context's instance of the modelview class.
     * @return CoursesCoordinator's object.
     */
    public static CoursesCoordinator getInstance(Context context) {
        if (instance == null) {
            instance = new CoursesCoordinator(context);
        }
        return instance;
    }

    /**
     * it searches for the course whose name is given.
     * @param courseName is the name of the target course
     * @return the found object related to the found course.
     */
    public CourseEntity getCourse(String courseName) {
        for (CourseEntity course : coursesList) {
            if (course.getName().equals(courseName)) {
                return course;
            }
        }
        return null; // nothing found
    }


    /*
    * It returns the courses' names
    * @return string list of courses
    */
    public List<String> getCoursesStr() {
        if (coursesList == null) {
            return null;
        }
        List<String> coursesStr = new ArrayList<>();
        for (CourseEntity course : coursesList) {
            coursesStr.add(course.getName());
        }
        return coursesStr;
    }


    /*
    * It returns the courses objects at a given day sorted by the starting time
    * @param day is the index that represents the days; zero is Sunday, and Friday is 5.
    * @return List<CourseEntity>
    */
    public List<CourseEntity> getCoursesDay(int day) {
        if (coursesList == null) { // to avoid race condition
            return null;
        }
        // filtering the courses
        List<CourseEntity> courses = new ArrayList<>();
        for (CourseEntity course : coursesList) {
            if (course.getFromHourNum()[day] != -1) {
                courses.add(course);
            }
        }
        // sorting the courses
        Collections.sort(courses, (o1, o2) -> {
            CourseEntity course1 = (CourseEntity) o1;
            CourseEntity course2 = (CourseEntity) o2;
            return Integer.compare((course1.getFromHourNum()[day] * 60) + course1.getFromMinuteNum()[day],
                    (course2.getFromHourNum()[day] * 60) + course2.getFromMinuteNum()[day]);
        });
        return courses;
    }


    /*
    * It creates and adds a course to the database and to the coursesList
    * @param name is the name of the course.
    * @param location is the room that holds the class.
    * @param sunFrom stores the starting time on sunday as hh:mm like 14:20; if the class does not
    *  occur on sundays, then it's assigned to empty string ""
    * @param sunTo stores the ending time on sunday as hh:mm like 14:20; if the class does not
    *  occur on sundays, then it's assigned to empty string ""
    * @param monFrom stores the starting time on Mondays as hh:mm like 14:20; if the class does not
    *  occur on Mondays, then it's assigned to empty string ""
    * @param monTo stores the ending time on Mondays as hh:mm like 14:20; if the class does not
    *  occur on Mondays, then it's assigned to empty string ""
    * @param TueFrom stores the starting time on Tuesdays as hh:mm like 14:20; if the class does not
    *  occur on Tuesdays, then it's assigned to empty string ""
    * @param tueTo stores the ending time on Tuesdays as hh:mm like 14:20; if the class does not
    *  occur on Tuesdays, then it's assigned to empty string ""
    * @param wedFrom stores the starting time on Wednesdays as hh:mm like 14:20; if the class does not
    *  occur on Wednesdays, then it's assigned to empty string ""
    * @param wedTo stores the ending time on Wednesdays as hh:mm like 14:20; if the class does not
    *  occur on Wednesdays, then it's assigned to empty string ""
    * @param thrFrom stores the starting time on Thursdays as hh:mm like 14:20; if the class does not
    *  occur on Thursdays, then it's assigned to empty string ""
    * @param thrTo stores the ending time on Thursdays as hh:mm like 14:20; if the class does not
    *  occur on Thursdays, then it's assigned to empty string ""
    * @param friFrom stores the starting time on Fridays as hh:mm like 14:20; if the class does not
    *  occur on Fridays, then it's assigned to empty string ""
    * @param friTo stores the ending time on Fridays as hh:mm like 14:20; if the class does not
    *  occur on Fridays, then it's assigned to empty string ""
    */
    public void addCourse(String name, String location,
                          String sunFrom, String sunTo, String monFrom, String monTo,
                          String tueFrom, String tueTo, String wedFrom, String wedTo,
                          String thrFrom, String thrTo, String friFrom, String friTo) {
        lastId++;
        CourseEntity added = new CourseEntity(lastId, name, location,
                sunFrom, sunTo, monFrom, monTo,
                tueFrom, tueTo, wedFrom, wedTo,
                thrFrom, thrTo, friFrom, friTo);

        coursesList.add(added);
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> repository.addCourse(added));
    }

    /*
    * It updates course object on database and coursesList
    * @param updated is the object after updating
    */
    public void updateCourse(CourseEntity updated) {
        int updatingIndex = 0;
        for (int i = 0; i < coursesList.size(); i++) {
            if (updated.getCourseID() == coursesList.get(i).getCourseID()) {
                updatingIndex = i;
            }
        }
        coursesList.set(updatingIndex, updated);

        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> repository.updateCourse(updated));

        // the database will remove everything related to the course because the foreign key are
        // cascade, so if the coordinators are not null, then their data may cache something related
        // to the deleted courses
        NoteCoordinator.nullifyInstance();
        FlashCardCoordinator.nullifyInstance();
    }

    /*
    * It removes the course from the database and from all cached lists if needed.
    * @param removed is the course that will be removed
    */
    public void removeCourse(CourseEntity removed, Context context) {
        int removingIndex = 0;
        for (int i = 0; i < coursesList.size(); i++) {
            if (removed.getCourseID() == coursesList.get(i).getCourseID()) {
                removingIndex = i;
            }
        }
        coursesList.remove(removingIndex);
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> repository.removeCourse(removed));

        // the database will remove everything related to the course because the foreign key are
        // cascade, so if the coordinators are not null, then their data may cache something related
        // to the deleted courses
        NoteCoordinator.nullifyInstance();
        FlashCardCoordinator.nullifyInstance();
    }
}
