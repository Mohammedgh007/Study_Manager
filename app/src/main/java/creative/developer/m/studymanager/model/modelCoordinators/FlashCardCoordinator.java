/*
###############################################################################
Author: Mohammed Alghamdi
Class name : FlashCardCoordinator
purpose: This is a model class that coordinates all model classes that are used by flash cards,
  so that view model need to interact only with this class. It has an access
  to both versions of the flash cards(the database and the cashed cards).
Methods:
    getInstance() -> returns the only instance of this class. This class implements Singleton.
    getCardsList() -> It is getter for the field cardsList. It's used to check if the instances has
     been fully initialized, so that the race condition is avoided.
    getLessonsList(course) -> returns the lessons that belongs to the given course.
    getLessonCards(course, lesson) -> returns the cards of the given lesson and course.
    addCard(course, lesson, question, answer) -> it adds a object card to
         cardsList of the given course and lesson, and it returns the created object.
    updateLesson(cards) ->  It updates the given cards in cardsList and update/add the cards in the database.
    removecard(removed) -> it removes the given card from the database and the cardsList.
    removeLesson(course, lesson) -> it removes the lesson's cards.
    nullifyInstance() -> It's called to make the field instance null, so that the only thing that
     needs to be updated the database.
Note: the following are used temporarily
    coursesNames -> names of the courses including the ones that do not have a lesson's cards. Cashed version.
    containCourse() -> returns true if the course has been added already.
    getCourses() -> returns Set<string> that contain courses' names.
Note: view model can uses "" as initial parameter value when calling addCard()
###############################################################################
 */

package creative.developer.m.studymanager.model.modelCoordinators;

import android.content.Context;

import java.lang.reflect.Array;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Observable;
import java.util.Set;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import creative.developer.m.studymanager.model.EntityListFiles.FlashCardsList;
import creative.developer.m.studymanager.model.dbFiles.AppDatabase;
import creative.developer.m.studymanager.model.dbFiles.DataRepository;
import creative.developer.m.studymanager.model.dbFiles.EntityFiles.FlashCardEntity;

public class FlashCardCoordinator extends Observable {
    // When adding a row in the database, the row's id is 1 + lastId, so that ids are generated by
    // this class instead of the database. It would behave like AUTO_INCREMENT.
    private int lastID;
    private FlashCardsList cardsList; // cashed data from database
    private static FlashCardCoordinator instance; // this class applies Singleton
    private Set<String> coursesNames;
    private DataRepository repository;

    /*
    * It constructs the only object of this class
    * @param context is the Context's object of the view model class.
    */
    private FlashCardCoordinator(Context context) {
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> {
            repository = DataRepository.getInstance(AppDatabase.getInstance(context));
            System.out.println("finish repo");
            cardsList = new FlashCardsList(repository.getCards());
            System.out.println("finish cards list");
            lastID = cardsList.getLastID();
            coursesNames = repository.getCoursesStr();
            System.out.println("finish coures");
            FlashCardCoordinator.this.setChanged();
            FlashCardCoordinator.this.notifyObservers();
        });
    }


    /*
    * It returns the only object of this class .
    * @param context is the Context's object of the view model class.
    */
    public static FlashCardCoordinator getInstance(Context context) {
        if (instance == null) {
            instance = new FlashCardCoordinator(context);
        }
        return instance;
    }

    /*
     It is getter for the field cardsList. It's used to check if the instances has
     been fully initialized, so that the race condition is avoided.
     */
    public FlashCardsList getCardsList() {
        return cardsList;
    }

    /*
     * It returns the names of the lessons associated with the given course's name.
     * @param course is the course's name.
     */
    public List<String> getLessonsList(String course) {
        return cardsList.getCourseLessons(course);
    }

    /*
    * It returns the card objects that are associated with the given course and lesson.
    * @param course is the course's name.
    * @param lesson is the lesson's name.
    */
    public List<FlashCardEntity> getLessonCards(String course, String lesson) {
        return cardsList.getLessonCards(course, lesson);
    }


    /*
    * It creates and adds a card object to cardsList only.
    * @param course is the course's name.
    * @param lesson is the lesson's name.
    * @param question is the typed question by the user.
    * @param answer is the typed answer by the user.
    * @return the created card object.
    */
    public FlashCardEntity addCard(String course, String lesson, String question, String answer) {
        lastID++;
        FlashCardEntity added = new FlashCardEntity(lastID, course, lesson, question, answer);
        cardsList.addCard(added);
        return added;
    }


    /*
    * It updates the lesson in cardsList and update/add the cards in the database
    * @param cards are the updated version of the card object.
    */
    public void updateLesson(List<FlashCardEntity> cards) {
        cardsList.updateLesson(cards);
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> {
            for (FlashCardEntity card : cards) {
                repository.addCards(card);
            }
        });
    }


    /*
    * It removes the given card from the database and cardsList.
    * @param removed is card's object that will be removed.
    */
    public void removecard(FlashCardEntity removed) {
        cardsList.removecard(removed);
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> repository.deleteCards(removed));
    }


    /*
    * It removes all the cards associated with the given lesson.
    * @param course is the course's name.
    * @param lesson is the lesson's name.
    */
    public void removeLesson(String course, String lesson) {
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> {
            for (FlashCardEntity card : cardsList.removeLesson(course, lesson)) {
                repository.deleteCards(card);
            }
        });
    }

    /*
    * It's called to make the instance null, which forces this class to use an updated version of
    * data from the database
    */
    public static void nullifyInstance() {
        instance = null;
    }

}
